<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Timmmmmms</title>
  
  <subtitle>Baby steps to Giant strides</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-13T06:18:27.380Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Timmmmmms</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决Google浏览器崩溃 错误代码：STATUS_INVALID_IMAGE_HASH</title>
    <link href="http://yoursite.com/2020/06/13/%E8%A7%A3%E5%86%B3Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B4%A9%E6%BA%83%20%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%EF%BC%9ASTATUS_INVALID_IMAGE_HASH/"/>
    <id>http://yoursite.com/2020/06/13/%E8%A7%A3%E5%86%B3Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B4%A9%E6%BA%83%20%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%EF%BC%9ASTATUS_INVALID_IMAGE_HASH/</id>
    <published>2020-06-13T06:06:20.892Z</published>
    <updated>2020-06-13T06:18:27.380Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3>问题描述<p>Google的chrome莫名其妙突然所有页面都显示“喔唷 崩溃啦”，各种插件在右下角弹出报错！</p><h3>解决方法<p>通过修改注册列表的方法，禁用Renderer Code Integrity Protection（渲染器代码完整性保护）可以解决，亲测可用。</p><h4>步骤<ol><li><p>Win+R输入regedit打开注册表编辑器</p></li><li><p>找到HKEY_LOCAL_MACHINE \ SOFTWARE \ Policies \ Google \ Chrome</p><p><strong>注意</strong>：不是HKEY_LOCAL_MACHINE \ SOFTWARE \Google</p><p>若没有此目录可以新建项,如下图红框所示</p></li><li><p>右键单击新建&gt;DWORD(32位)值以创建新密钥</p></li><li><p>将值名称改为RendererCodeIntegrityEnabled，并将值数据输入为0</p></li><li><p>重新启动chrome</p></li></ol><p><img src="C:%5CUsers%5CTim%5CDesktop%5C%E5%BE%85%E6%9B%B4%E6%96%B0%5C111.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;问题描述

&lt;p&gt;Google的chrome莫名其妙突然所有页面都显示“喔唷 崩溃啦”，各种插件在右下角弹出报错！&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>自定义错误信息</title>
    <link href="http://yoursite.com/2020/06/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2020/06/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</id>
    <published>2020-06-13T05:15:22.739Z</published>
    <updated>2020-04-20T10:17:46.734Z</updated>
    
    <content type="html"><![CDATA[<h1>自定义错误信息<p>项目中用到的错误信息定义</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><a id="more"></a><h1>目标：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    status: "success",</span><br><span class="line">        data: &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        name: "tim",</span><br><span class="line">        gender: 1,</span><br><span class="line">        age: 22,</span><br><span class="line">        telphone: "123456789"</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    status: "fail",</span><br><span class="line">        data: &#123;</span><br><span class="line">        errCode: 20001,</span><br><span class="line">        errMsg: "用户不存在"</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.定义一个用于返回前端的json结果 CommonReturnType<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表明对应请求的返回处理结果“success" 或"fail"</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若status==success 则data内返回前端需要的json数据</span></span><br><span class="line">    <span class="comment">//若status==fail  则data内使用通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个通用的创建方法</span></span><br><span class="line">    <span class="comment">//若调用此方法则返回是success</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可自定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result, String status)</span></span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>若success直接输出信息，怎样定义错误样式才是关键<h3>2.定义CommonError接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3.定义EmBusinessError枚举类继承CommonError接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用错误类型10001</span></span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10001</span>, <span class="string">"参数不合法"</span>),</span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//200000开头为用户信息相关错误定义</span></span><br><span class="line">    USER_NOT_EXIST(<span class="number">20001</span>, <span class="string">"用户不存在"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errCode, String errMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errCode = errCode;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errCode;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>4.定义BusinessException类继承exception 并实现CommonError<p><strong>此处用到装饰器设计模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接接收EmBusinessError的传参用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        commonError.setErrMsg(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrMsg(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>5.可在BaseController拦截exception 返回对应的自定义异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义exceptionhandler解决未被controller层吸收的exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> BusinessException)&#123;</span><br><span class="line">            BusinessException businessException = (BusinessException)ex;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, businessException.getErrMsg());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, EmBusinessError.UNKNOWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData,<span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;自定义错误信息


&lt;p&gt;项目中用到的错误信息定义&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线程安全的单例模式</title>
    <link href="http://yoursite.com/2020/06/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/06/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-13T05:15:22.738Z</published>
    <updated>2020-04-18T09:09:09.787Z</updated>
    
    <content type="html"><![CDATA[<h1>线程安全的单例模式<h3>1.懒汉模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//懒汉式，要用的时候才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：线程不安全，延迟初始化，严格意义上不是不是单例模式</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><a id="more"></a><h3>2.饿汉式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//饿汉式，一开始就是初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：容易产生垃圾， 但是线程安全</p><h3>3.双重检查加锁版(推荐⭐)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.创建volatile修饰的实列（①.volatile保证内存可见性</span></span><br><span class="line">    <span class="comment">//②.volatile可以防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.暴露给可以类外调用的静态方法应用实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一重校验</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstace == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//第二重校验（防止当进入同步块后实例已经被创建</span></span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">  uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>1.保证线程安全</p><p>2.防止指令重排</p><p>3.双重检查优化</p><h3>4.静态内部类方式（推荐⭐⭐）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance()方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。</p><h3>5.枚举单例模式(很少用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">INSTANCE</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">return Singleton.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;线程安全的单例模式


&lt;h3&gt;1.懒汉模式


&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//懒汉式，要用的时候才初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;缺点：线程不安全，延迟初始化，严格意义上不是不是单例模式&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库隔离级别</title>
    <link href="http://yoursite.com/2020/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2020/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-06-13T05:15:22.735Z</published>
    <updated>2020-04-14T03:55:51.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1  事务"></a>1  事务</h3><p>事务只是一个改变，是一些的操作集合；用专业的术语去解释，就是一个程序的执行单元；事务本身并不包含这四个特性，我们需要通过某些手段，尽可能让这个执行单元满足这四个特性，那么，我们就可以称它是一个事务，或者说是一个正确的，完美的事务。</p><h3 id="2-四特性"><a href="#2-四特性" class="headerlink" title="2  四特性"></a>2  四特性</h3><ul><li>原子性：满足原子操作单元，对数据的操作，要么全部执行，要么全部不执行。</li><li>一致性：事务开始和完成时，数据都必须保持一致。</li><li>隔离性：事务之间相互独立，中间状态对外部不可见。</li><li>持久性：数据的修改是永久性的，即使系统出现任何故障都能够保持。</li></ul><h3 id="3-隔离级别"><a href="#3-隔离级别" class="headerlink" title="3  隔离级别"></a>3  隔离级别</h3><a id="more"></a><h4 id="3-1-并发情况下事务引发的问题"><a href="#3-1-并发情况下事务引发的问题" class="headerlink" title="3.1  并发情况下事务引发的问题"></a>3.1  并发情况下事务引发的问题</h4><blockquote><p>一般情况下，多个单元操作（事务，这里的事务，并不是完美的事务）并发执行，会出现这么几个问题：</p></blockquote><ul><li>脏读：A事务还未提交，B事务就读到了A操作的结果。（破坏了隔离性）</li><li>不可重复读：A事务在本次事务中，对自己未操作过数据，进行多次读取，结果出现不一致或记录不存在的情况。（破坏了一致性，重点是update和delete）</li><li>幻读：A事务在本次事务中，先读取了一遍数据，发现数据不存在，过了一会，又读取了一遍，发现又有数据了。（破坏了一致性，重点是insert）</li></ul><h4 id="3-2-解决（制定标准）"><a href="#3-2-解决（制定标准）" class="headerlink" title="3.2  解决（制定标准）"></a>3.2  解决（制定标准）</h4><p>为了权衡『隔离』和『并发』的矛盾，ISO定义了4个事务隔离级别，每个级别隔离程度不同，允许出现的副作用也不同。</p><ul><li>未提交读（read-uncommitted）：最低级别，基本只保证持久性；会出现脏读，不可重复读，幻读的问题。</li><li>已提交读（read-committed）：语句级别；会出现不可重复读，幻读的问题。</li><li>可重复读（repeatable-read）：事务级别；只会出现幻读问题。</li><li>串行化（serializable）：最高级别，也就是事务与事务完全串行化执行，无并发可言，性能低；但不会出现任何问题。</li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>会</td><td>会</td><td>会</td></tr><tr><td>不可重复读（read-committed）</td><td>-</td><td>会</td><td>会</td></tr><tr><td>可重复读（repeatable-read）</td><td>-</td><td>-</td><td>会</td></tr><tr><td>串行化（serializable）</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>注意：这四个级别只是一个标准，各个数据库厂商，并不完全按照标准做的。</p><h4 id="3-2-实现（InnoDB）"><a href="#3-2-实现（InnoDB）" class="headerlink" title="3.2  实现（InnoDB）"></a>3.2  实现（InnoDB）</h4><ul><li><p>锁机制：阻止其他事务对数据进行操作， 各个隔离级别主要体现在读取数据时加的锁的释放时机。</p><ul><li><p>RU：事务读取时不加锁</p></li><li><p>RC：事务读取时加行级共享锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）。</p></li><li><p>RR：事务读取时加行级共享锁，直到事务结束时，才会释放。</p></li><li><p>SE：事务读取时加表级共享锁，直到事务结束时，才会释放。</p></li></ul><blockquote><p>其他还有一些细节不同，主要就是这些</p></blockquote></li><li><p>MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性读取，也称为多版本数据控制。</p><ul><li>实际就是『版本控制』加『读写分离』思想，主要用作于RC和RR级别。</li><li>这里面就太细了，主要涉及到事务原理和索引，就不讲了，因为！第一：面试要求讲MVCC的原理比较少，第二：主要我讲了你必然记不住，这也是为什么问的比较少的原因了，因为面试官自己肯定是记不住的。除非像在下一样，每天每天的看，感觉忘了就看。一般人也做不到。如果面试被问到了，肯定是面试官上班无聊，刷到一些软文，自己看了看，觉得写得很好，随口就问了。但不得不说，现在的技术软文，写得，都是什么大便。还有随便吹一下自己的经验，说一些心得，点击收藏就好几万的。我哪天也开始做这种视频，不做技术讲解了。直接做吹牛逼的视频，天天给观众讲道理，灌鸡汤。攒个几十万粉丝再说。但是，好吧，在下不是这种人。这行没别的，就一个字，学，讲多了都是P话。</li></ul></li></ul><h3 id="4-结构图"><a href="#4-结构图" class="headerlink" title="4  结构图"></a>4  结构图</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库隔离级别&quot;&gt;&lt;a href=&quot;#数据库隔离级别&quot; class=&quot;headerlink&quot; title=&quot;数据库隔离级别&quot;&gt;&lt;/a&gt;数据库隔离级别&lt;/h2&gt;&lt;h3 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; title=&quot;1  事务&quot;&gt;&lt;/a&gt;1  事务&lt;/h3&gt;&lt;p&gt;事务只是一个改变，是一些的操作集合；用专业的术语去解释，就是一个程序的执行单元；事务本身并不包含这四个特性，我们需要通过某些手段，尽可能让这个执行单元满足这四个特性，那么，我们就可以称它是一个事务，或者说是一个正确的，完美的事务。&lt;/p&gt;
&lt;h3 id=&quot;2-四特性&quot;&gt;&lt;a href=&quot;#2-四特性&quot; class=&quot;headerlink&quot; title=&quot;2  四特性&quot;&gt;&lt;/a&gt;2  四特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原子性：满足原子操作单元，对数据的操作，要么全部执行，要么全部不执行。&lt;/li&gt;
&lt;li&gt;一致性：事务开始和完成时，数据都必须保持一致。&lt;/li&gt;
&lt;li&gt;隔离性：事务之间相互独立，中间状态对外部不可见。&lt;/li&gt;
&lt;li&gt;持久性：数据的修改是永久性的，即使系统出现任何故障都能够保持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-隔离级别&quot;&gt;&lt;a href=&quot;#3-隔离级别&quot; class=&quot;headerlink&quot; title=&quot;3  隔离级别&quot;&gt;&lt;/a&gt;3  隔离级别&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="http://yoursite.com/2020/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>http://yoursite.com/2020/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</id>
    <published>2020-06-13T05:15:22.733Z</published>
    <updated>2020-06-13T06:08:32.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-宏观"><a href="#1-宏观" class="headerlink" title="1 宏观"></a>1 宏观</h2><h3 id="1-1-数据库锁"><a href="#1-1-数据库锁" class="headerlink" title="1.1 数据库锁"></a>1.1 数据库锁</h3><ul><li>数据库锁适用于集群</li><li>粒度小，更方便控制</li></ul><h3 id="1-2-代码锁"><a href="#1-2-代码锁" class="headerlink" title="1.2 代码锁"></a>1.2 代码锁</h3><ul><li><p>需要复杂的处理，才能作用于集群</p></li><li><p>粒度大</p></li></ul><h2 id="2-微观"><a href="#2-微观" class="headerlink" title="2 微观"></a>2 微观</h2><a id="more"></a><h3 id="2-1-行锁-amp-表锁"><a href="#2-1-行锁-amp-表锁" class="headerlink" title="2.1 行锁 &amp; 表锁"></a>2.1 行锁 &amp; 表锁</h3><h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><p><strong>只有「明确」指定主键，才会执行锁，否则将会执行表锁</strong></p><h4 id="2-1-2-示例"><a href="#2-1-2-示例" class="headerlink" title="2.1.2 示例"></a>2.1.2 示例</h4><p>假设有个表 products ，字段id、name、type，id是主键。</p><ul><li><p>无锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 明确指定主键，但不存在该主键的值(没有数据，当然不会有锁)</span><br><span class="line">SELECT * FROM products WHERE id&#x3D;-1 FOR UPDATE;</span><br></pre></td></tr></table></figure></li><li><p>行锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 明确指定主键</span><br><span class="line">SELECT * FROM products WHERE id&#x3D;3 FOR UPDATE;</span><br><span class="line">SELECT * FROM products WHERE id&#x3D;3 AND type&#x3D;1 FOR UPDATE;</span><br></pre></td></tr></table></figure></li><li><p>表锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 主键不明确</span><br><span class="line">SELECT * FROM products WHERE name&#x3D;&#39;Mouse&#39; FOR UPDATE;</span><br><span class="line">SELECT * FROM products WHERE id&lt;&gt;&#39;3&#39; FOR UPDATE;</span><br><span class="line">SELECT * FROM products WHERE id LIKE &#39;3&#39; FOR UPDATE;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-3-注意"><a href="#2-1-3-注意" class="headerlink" title="2.1.3 注意"></a>2.1.3 注意</h4><ul><li>要测试锁定的状况，可以利用 MySQL 的 Command Mode ，开二个视窗来做测试。</li><li>MyISAM 只支持表级锁，InnoDB支持行级锁添加了（行级锁、表级锁）锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除） 。是表级锁时，不管是否查询到记录，都会锁定表。</li></ul><h3 id="2-2-行锁算法"><a href="#2-2-行锁算法" class="headerlink" title="2.2 行锁算法"></a>2.2 行锁算法</h3><h4 id="2-2-1-Record-Lock（普通行锁）"><a href="#2-2-1-Record-Lock（普通行锁）" class="headerlink" title="2.2.1 Record Lock（普通行锁）"></a>2.2.1 Record Lock（普通行锁）</h4><ul><li>对于键值在条件范围内，且存在的记录，使用” Record Lock “，即普通的行锁机制；</li></ul><h4 id="2-2-2-Gap-Lock（间隙锁）"><a href="#2-2-2-Gap-Lock（间隙锁）" class="headerlink" title="2.2.2 Gap Lock（间隙锁）"></a>2.2.2 Gap Lock（间隙锁）</h4><ul><li>对于键值在条件范围内但并不存在的记录，叫做” 间隙（GAP) “，InnoDB会对这个“间隙”加锁，这种锁机制就是所谓的” Gap Lock “(间隙锁)；</li></ul><h4 id="2-2-3-Next-Key-Lock（行-amp-间隙）"><a href="#2-2-3-Next-Key-Lock（行-amp-间隙）" class="headerlink" title="2.2.3 Next-Key Lock（行 &amp; 间隙）"></a>2.2.3 Next-Key Lock（行 &amp; 间隙）</h4><ul><li><p>对于存在于不存在的数据同时加锁，则称为” Next-Key Lock “；</p></li><li><p><strong>Next-Key Lock包含Record Lock和Gap Lock；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假如user表中只有101条记录，empid的值是1,2,...,100,101</span></span><br><span class="line"><span class="comment"># 范围条件的检索，会对值为101的记录加锁，也会对大于101（不存在）加锁</span></span><br><span class="line"><span class="comment"># 由于两个锁同时存在，则此处为 Next-Key Lock</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  <span class="keyword">user</span> <span class="keyword">where</span> user_id &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-表锁算法"><a href="#2-3-表锁算法" class="headerlink" title="2.3 表锁算法"></a>2.3 表锁算法</h3><h4 id="2-3-1-意向锁"><a href="#2-3-1-意向锁" class="headerlink" title="2.3.1 意向锁"></a>2.3.1 意向锁</h4><ul><li><p>当一个事务带着表锁去访问一个被加了行锁的资源，那么，此时，这个行锁就会升级为意向锁，将表锁住。</p></li><li><p>常用的意向锁有：意向共享锁，意向排它锁，共享意向排它锁</p></li></ul><h4 id="2-3-2-自增锁"><a href="#2-3-2-自增锁" class="headerlink" title="2.3.2 自增锁"></a>2.3.2 自增锁</h4><ul><li><p>事务插入自增类型的列时获取自增锁</p><blockquote><p>如果一个事务正在往表中插入自增记录，所有其他事务的插入必须等待</p></blockquote></li></ul><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h2><h3 id="3-1-共享锁-amp-排它锁"><a href="#3-1-共享锁-amp-排它锁" class="headerlink" title="3.1 共享锁 &amp; 排它锁"></a>3.1 共享锁 &amp; 排它锁</h3><blockquote><p>行锁和表锁是锁粒度的概念，共享锁和排它锁是他们的具体实现</p></blockquote><h4 id="3-1-1-共享锁（S）：读锁"><a href="#3-1-1-共享锁（S）：读锁" class="headerlink" title="3.1.1 共享锁（S）：读锁"></a>3.1.1 共享锁（S）：读锁</h4><ul><li>允许一个事务去读一行，阻止其他事务获取该行的排它锁。</li><li>多事务时，只能加共享读锁，不能加排他写锁；单事务时，可以加任何锁。</li><li>一般理解为：能读，不能写。</li></ul><h4 id="3-1-2-排它锁（X）：写锁"><a href="#3-1-2-排它锁（X）：写锁" class="headerlink" title="3.1.2 排它锁（X）：写锁"></a>3.1.2 排它锁（X）：写锁</h4><ul><li>允许持有排它锁的事务读写数据，阻止其他事物获取该数据的共享锁和排它锁。</li><li>其他事务不能获取该数据的任何锁，直到排它锁持有者释放。</li><li>不能获取任何锁，不代表不能无锁读取。</li></ul><p><strong><font color="red">注意</font></strong></p><ul><li><p>排它锁指的是，在某个事务获取数据的排它锁后，其他事务不能获取该数据的任何锁，<br><strong>并不代表其他事务不能无锁读取该数据。</strong></p><ul><li><font color="red">无锁</font><ul><li><strong>select … from</strong></li></ul></li><li><font color="red">共享锁</font><ul><li><strong>select … lock in share mode</strong></li></ul></li><li><font color="red">排它锁</font><ul><li><strong>update</strong></li><li><strong>delete</strong></li><li><strong>insert</strong></li><li><strong>select … for update</strong></li></ul></li></ul></li><li><p>MySQL8.0 中，使用 FOR SHARE 替代了 LOCK IN SHARE MODE，但仍然支持 LOCK IN SHARE MODE；<br>虽然是等价的，但是 FOR SHARE 支持 NOWAIT 、 SKIP LOCKED 等，配合自旋，可以实现高效的等待队列。</p></li></ul><h3 id="3-2-乐观锁-amp-悲观锁"><a href="#3-2-乐观锁-amp-悲观锁" class="headerlink" title="3.2 乐观锁 &amp; 悲观锁"></a>3.2 乐观锁 &amp; 悲观锁</h3><blockquote><p>不管是什么锁都需要增加，需加失败重试</p></blockquote><h4 id="3-2-1-乐观锁"><a href="#3-2-1-乐观锁" class="headerlink" title="3.2.1 乐观锁"></a>3.2.1 乐观锁</h4><ul><li><p>通过版本号来进行更新的操作属于乐观锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tab <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'xxx'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = xxx</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-2-悲观锁"><a href="#3-2-2-悲观锁" class="headerlink" title="3.2.2 悲观锁"></a>3.2.2 悲观锁</h4><blockquote><p>共享锁 &amp; 排它锁都是悲观锁的具象实现</p></blockquote><ul><li>显示地控制行或表锁属于悲观锁</li></ul><h2 id="4-原理"><a href="#4-原理" class="headerlink" title="4  原理"></a>4  原理</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-宏观&quot;&gt;&lt;a href=&quot;#1-宏观&quot; class=&quot;headerlink&quot; title=&quot;1 宏观&quot;&gt;&lt;/a&gt;1 宏观&lt;/h2&gt;&lt;h3 id=&quot;1-1-数据库锁&quot;&gt;&lt;a href=&quot;#1-1-数据库锁&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据库锁&quot;&gt;&lt;/a&gt;1.1 数据库锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库锁适用于集群&lt;/li&gt;
&lt;li&gt;粒度小，更方便控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-代码锁&quot;&gt;&lt;a href=&quot;#1-2-代码锁&quot; class=&quot;headerlink&quot; title=&quot;1.2 代码锁&quot;&gt;&lt;/a&gt;1.2 代码锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要复杂的处理，才能作用于集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;粒度大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-微观&quot;&gt;&lt;a href=&quot;#2-微观&quot; class=&quot;headerlink&quot; title=&quot;2 微观&quot;&gt;&lt;/a&gt;2 微观&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>String,StringBuilder,StringBuffer</title>
    <link href="http://yoursite.com/2020/06/13/String,StringBuilder,StringBuffer/"/>
    <id>http://yoursite.com/2020/06/13/String,StringBuilder,StringBuffer/</id>
    <published>2020-06-13T05:15:22.731Z</published>
    <updated>2020-04-14T03:57:21.607Z</updated>
    
    <content type="html"><![CDATA[<h1>Stirng, StringBuild, StringBuffer底层代码浅析<h3>String 为什么是不可变的？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>String中声明字符数组value用final修饰，故String是内容不可变的字符串</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><a id="more"></a><h3>StringBuild<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>StringBuilder 继承 AbstractStringBuilder，在AbstractStringBuilder中声明了数组方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><p>可以看到StringBuilder中声明字符数组并没有用final修饰，故是内容可变的字符串</p><h3>StringBuffer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure><p>StringBuffer和StringBuilder在声明字符数组的方式一致；StringBuffer是线程安全的，而StringBuilder不是，所有StringBuffer所有的方法上都加上了 synchronized 修饰。</p><p>但是有趣的时StringBuffer 比StringBuilder 多了一个toStringCache的一个缓存，这个toStringCache到底有什么用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure><p>Stack Overflow ：<a href="https://stackoverflow.com/questions/46294579/why-stringbuffer-has-a-tostringcache-while-stringbuilder-not" target="_blank" rel="noopener">https://stackoverflow.com/questions/46294579/why-stringbuffer-has-a-tostringcache-while-stringbuilder-not</a></p><p>toStringCache是一个缓存，缓存最后一次toString的值，当StringBuffer被修改施会清除。反之，若没有被修改，toStringCache就缓存toString的结果。</p><p>所有要继续了解toStringCache 就要来到toString这个方法上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可以看到，当调用toString方法，若toStringCache存在时就会直接用new String(toStringCache, true);  这样就不用进行复制操作了。</p><h1>待续<p>比较</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Stirng, StringBuild, StringBuffer底层代码浅析

&lt;h3&gt;String 为什么是不可变的？

&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** The value is used for character storage. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; value[];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;String中声明字符数组value用final修饰，故String是内容不可变的字符串&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2020/06/13/Linux/"/>
    <id>http://yoursite.com/2020/06/13/Linux/</id>
    <published>2020-06-13T05:15:22.729Z</published>
    <updated>2020-04-16T09:04:10.616Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux常用命令<h4>    <p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><a id="more"></a><p>Linux文件类型常见的有：<br>（1）普通文件：符号是 -<br>（2）目录文件：符号是 d<br>（3）字符设备文件：符号是c<br>（4）块设备文件：符号是b<br>（5）符号链接文件：符号是l</p><h3>常见目录说明：<h4><ol><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ol><h4><h1>一些常用命令<h2>1.目录切换<h4><ol><li><strong><code>cd usr</code>：</strong> 切换到该目录下usr目录</li><li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li><li><strong><code>cd /</code>：</strong> 切换到系统根目录</li><li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li><li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li></ol><h4><h2>2.关于目录的增删改查<h4><ol><li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p></li><li><p><strong><code>ls或者ll</code></strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p></li><li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p><p>示例：</p><ul><li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li><li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li><li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li><li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li></ul></li><li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p><p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p></li><li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）</p><p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p></li><li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝</p><p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p></li><li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p></li></ol><h4><h2>3.文件的增删改查<h4><ol><li><p><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）</p></li><li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p><ul><li><strong><code>cat</code>：</strong> 查看显示文件内容</li><li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li><li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li><li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li></ul><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化</p></li><li><p><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p></li><li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p><p>同目录删除：熟记 <code>rm -rf</code> 文件 即可</p></li></ol><h4><h2>4.解压和压缩文件<h4><p><strong>打包并压缩文件：</strong></p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong> 其中：</p><p>z：调用gzip压缩命令进行压缩</p><p>c：打包文件</p><p>v：显示运行过程</p><p>f：指定文件名</p><p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code></strong></p><p><strong>解压压缩包：</strong></p><p>命令：tar [-xvf] 压缩文件</p><p>其中：x：代表解压</p><p>示例：</p><p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p><p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p><h4><h2>5.权限命令<h4><p>权限分为：读，写，执行</p><ol><li>r：代表权限是可读，r也可以用数字4表示</li><li>w：代表权限是可写，w也可以用数字2表示</li><li>x：代表权限是可执行，x也可以用数字1表示</li></ol><p>常见考题：<strong><code>chmod 755  name.txt</code></strong> 设置用户权限为：</p><p>​                    1.文件所有者：可读可写可执行</p><p>​                    2.与文件所有者同属一个用户组的其他用户：可读可执行</p><p>​                    3.其他用户组：可读可执行</p><p>​                <strong><code>chmod u=rwx, g=rw, o=r    name.txt</code></strong></p><p>​                <strong><code>chmod -R u=rwx,g=rwx,o=rwx ./log</code></strong> // 递归给log目录下的所有文件授权</p><p>可读可执行(rx = 5 = 4 + 1)</p><p>可读可写(rw = 6 = 4 + 2)</p><p>可读可写可执行(rwx = 7 = 4 + 2 + 1)</p><p>对于文件：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以使用cat查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用cd进入目录</td></tr></tbody></table><p>网上找到的 将应用随<strong>开机自动启动</strong>的方法：</p><p>假如我们装了一个zookeeper，要求它自动启动</p><ol><li>新建一个脚本zookeeper</li><li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li><li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add  zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li></ol><h4><h2>6.用户管理<h4><ol><li><code>useradd 选项 用户名</code>:添加用户账号</li><li><code>userdel 选项 用户名</code>:删除用户帐号</li><li><code>usermod 选项 用户名</code>:修改帐号</li><li><code>passwd 用户名</code>:更改或创建用户的密码</li><li><code>passwd -S 用户名</code> :显示用户账号密码信息</li><li><code>passwd -d 用户名</code>: 清除用户密码</li></ol><h4><h2>7.其他常用命令<h4><ol><li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p></li><li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p></li><li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p></li><li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）先用ps查找进程，然后用kill杀掉</p></li></ol><ol start="6"><li><p>查看当前系统的网卡信息：ifconfig</p></li><li><p>查看与某台机器的连接情况：ping</p></li><li><p>查看当前系统的端口使用：netstat -an</p></li><li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p></li></ol><h4><h2 id="查找命令：Linux命令大全"><a href="#查找命令：Linux命令大全" class="headerlink" title="查找命令：Linux命令大全"></a><strong>查找命令：<a href="https://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a></strong></h2>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Linux常用命令

&lt;h4&gt;    

&lt;p&gt;&lt;strong&gt;在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git命令的使用</title>
    <link href="http://yoursite.com/2020/06/13/Git%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/13/Git%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-13T05:15:22.727Z</published>
    <updated>2020-04-15T10:30:49.105Z</updated>
    
    <content type="html"><![CDATA[<h1> Git基本命令的使用<h4>本地创建新分支并切换到新分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure><h4>提交分支到远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><a id="more"></a><h4>将远程仓库（github对应的项目）复制到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><h4>切换分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><h4>删除远程分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete 分支名</span><br></pre></td></tr></table></figure><h4>删除本地分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 分支名</span><br></pre></td></tr></table></figure><h4>查看当前分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h4>查看所属分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt; Git基本命令的使用


&lt;h4&gt;本地创建新分支并切换到新分支

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b 分支名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h4&gt;提交分支到远程仓库

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin 分支名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
